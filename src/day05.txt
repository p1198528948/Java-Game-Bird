软件开发过程 高大上
 1 软件需求
   1）飞扬小鸟游戏中有一只鸟在天空飞翔，前面遇到了很多
   有开口的柱子，鸟要飞过开口通过柱子，碰到柱子或者到地面
   就是死了，鸟不向上飞翔，就自由下落到地面。
   2）游戏有3种状态 开始  游戏中 结束
   
 2 需求分析 （找对象，找关系）
   飞扬小鸟游戏
    |-- 一只鸟
    |-- 柱子*n
    |-- 地面
 3 数学模型定义:使用什么的数据能够描述以上对象的行为关系
   类似于“解析几何”课程。
   目的是：将对象有数据进行描述，将对象转化为数据，将
   对象的行为动作，转化为数据的计算。
   如：地面的运动，可以转化为 x--
   
      飞扬小鸟游戏
    |-- 一只鸟 
    |    |-- image, x, y, width, height, size
    |-- 柱子*2
    |    |-- image, x, y, width, height
    |-- 地面
         |-- image, x, y
   
      
 4 类的概要设计:根据数据设计"类"，也就是软件的零件。
  
  Ground 地面
    |-- image
    |-- x，y
    
  Column 柱子
    |-- image 柱子的贴图
    |-- x，y 位置，以柱子的中心点为位置
    |-- width, height 宽高
    |-- gap 缝隙 
   
  Bird
    |-- image
    |-- x，y 位置，以中心为坐标位置
    |-- width，height 宽高
    |-- size 是鸟的碰撞检查范围大小，是一个方形区域
  
  Game
    |-- Bird bird 
    |-- Column column1, column2
    |-- Ground ground
    |-- background
 
 5 数据初始化设计
   设计构造器，初始化对象的数据。
    每一种类型都初始化自己的数据：
    如：柱子的构造器初始化柱子的初始入场位置（数据）
    鸟，地面，Game ...
 
 6 界面绘制：利用数据绘制界面
   利用Java的API将数据绘制到界面，显示出效果
   1) 将Game继承与JPanel：自定义的绘制要从空白面板扩展
   2) 重写paint() 方法，修改原有的绘制过程，增加自定义
   绘制过程。
     A 绘制背景(清理原有屏幕作用)
     B 绘制柱子 * 2
     C 绘制地面
 	 D 绘制分数 ？
 	 E 绘制鸟
   3) 在main方法中创建窗口，将Game放到窗口中显示出来。
 	
 7 算法设计（找行为）：功能设计，软件的功能最终都是利用数据的计算
 实现。数据的计算过程称为算法。
   1）地面的移动
     A 是地面在移动，是地面的功能
     B 要定义方法step()，在地面类型中定义这个方法
     C 利用地面的数据实现这个功能
       x--
     D 在Game中添加主循环，调用地面的移动功能，
     地面每移动一次，重新绘制界面一次，显示地面的新位置数据
     E 主循环要 休眠 1/60 秒
     F 在main中调用主循环 action()
   
   2）柱子的移动
     A 是柱子的功能
     B 在柱子类的内部添加 step() 方法
     C 利用柱子的数据计算实现移动的功能
     D 在主循环action()中调用柱子移动的方法。
   
   3）鸟的飞翔（扇动翅膀）
     逐帧动画：利用视觉暂留现象，按照一定的频率播放静止画面
     视觉感受就是连续动画。
     播放频率：1/7 ~ 1/30秒  就是 7~30赫兹
     
     A 读取全部的动画帧图片到内存中，用数组存储
       利用构造器：读取初始化动画帧图片
       在Bird中添加 BufferedImage[] images;
       在构造器中，创建数组，加载每个图片对象到 数组中
       在Bird 定义一个index变量，代表取图片的序号
     B 在鸟中添加 fly()飞翔方法 
     C 飞翔是算法是 每次利用取余运算循环更换动画帧图片
     D 在 主循环中调用飞翔方法
   
   4）鸟的移动（垂直上抛运动）
     垂直上抛运动: 公式 s = v0*t + g*t*t/2  v = v0 - g*t;
     A 在Bird类添加已知属性：
       g 重力加速度
       vs 最初上抛速度
       t 是固定间隔时间
     B 在Bird类添加运算过程变量：
       v 经过时间t以后达到的速度
       s 经过时间t鸟移动的位移
       v0 本次上抛的初始速度
     C 在构造器中初始化属性
     	g=4.5;
		vs = 20;
		t = 0.25;
		v0=vs;
		s=0;
		v=0;
     D 增加 移动方法 step() 
          利用垂直上抛运动，计算下次出现鸟的 y’
      y’ = y-s;
         得到y的位置
	public void step(){
		s = v0 * t + g*t*t/2;
		v = v0 - g * t;
		v0 = v;
		y = (int)(y - s);
		//调试代码
		if(y>500){
			y = 280;
			v0 = vs;
		}
	}

     E 在主循环中调用 step()方法。
      
   5）鸟的飞扬方法 flappy()
     将鸟的上抛初始速度，改为最初上抛速度，重新抛起
     public void flappy(){
       v0 = vs;
     }         
   
   6) 鸟的倾角计算
    A
    B
    C
   
   7）鼠标点击事件处理
     利用Java的API来获取鼠标事件的。利用Java定义的标准API
     获得鼠标是啥时候点击的。要用Java 的API必须遵守Java的
     约定，按照Java的约定书写鼠标处理代码，获得鼠标何时点
     点击的事件。
     A 实现监听器：实现MouseListener 或继承 MouseAdapter
       实现鼠标事件处理的约定方法：
       mousePressed()  方法：在鼠标按键按下时候执行
       执行 bird.flappy()
     
     B 将实现的监听器注册到 Game面板中，获得当鼠标在
     Game面板上点击时候，执行mousePressed()。
       
     C 在游戏开始时候，就要发起鼠标事件监听。这些代码在
     action方法中添加。
   
   8）计分
     分析：什么时候计分：鸟穿越柱子时候计分。
     鸟的位置：x，y  柱子的位置：x，y
     A 在Game中添加 score计分
     B 在Game构造器中初始化 score=0
     C 在主循环中，当鸟和柱子移动以后，检查柱子是否和鸟
     的x坐标重回，如果重回就加一分。
     D 修改 paint方法，将分数绘制出来。    
   
   9）碰撞检查
     原理：鸟如果在柱子范围之内，并且不在缝隙之内，就撞上
     A 在柱子上添加方法  hitBy(Bird bird) 返回值，也就是
     检查碰撞的结果：true表示碰上，false表示没有碰到
     柱子的内部有柱子数据，参数bird传递被检查的鸟数据
     根据柱子和鸟的数据检查是否碰到。
     
     B 实现算法：...
     
     C 在主循环中 每当 鸟走一步 柱子移动一步以后 检查是否
     发生碰撞，如果发生碰撞 游戏就结束。（输出“碰撞”）
      
   10）游戏状态管理
   分析：
 状态事件             点击鼠标        碰撞          点击鼠标
 状态             start-->running-->game over-->start
 状态值             0       1           2         0
  
  状态的保存位置：在Game上保存游戏的状态
 用常量表示3种状态：START RUNNING GAME_OVER
   
  状态转换效果：
   A start状态，游戏初始状态 
      鸟在飞，不能移动，地面走，柱子不动，显示游戏开始屏幕
   B RUNNING 状态 
      鸟飞，也移动，地面移动，柱子移动，不显示开始屏幕
   C GAME OVER 状态
      鸟不能飞，不能移动，地面不能移动，柱子不能移动，显示
      Game Over 屏幕
  
 状态转换
    点击鼠标 ：如果是开始状态，就切换到 RUNNING
    running 或 start 状态，可以执行飞扬     
       如果是Game Over状态，就不能飞扬，要切换到start
       要初始化数据（柱子，鸟，分数）。
    
    碰撞：将游戏切换到 GameOver      
    
  
  如何实现：
    A 在Game类中增加属性 state 代表当前游戏的状态
    B 在Game类中增加3个常量 
         START = 0 
         RUNNING = 1 
         GAME_OVER= 2
    C 重构鼠标事件：... 
    D 重构主循环：...
    E 重构paint方法，增加显示效果
      增加 两张图片的加载。
    
        
 
 index   = 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
 index/3 = 0 0 0 1 1 1 2 2 2 3 3  3  4  
index/3%8= 0 0 0 1 1 1 2 2 2 3 3  3  4 
 
 
 
 
 
 
 
 
 
 
 
 
 
 